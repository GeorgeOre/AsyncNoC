/*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                              ;
;                             parentchildtest.act  	                           ;
;                                 George Ore                                   ;
;                                                                              ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 Description: This file contains modules used to test the capabilies of a relay
               NoC. This is a test of that test.
 Goal: Fine tune the testing environment for the NoC.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            Required Namespace Imports                        */
import sim;     // Simulation library namespace
/*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            Table of Contents
        Process Name    |       Purpose
    testchild           |   Simulates a child that actively sends data on a bus
    testroot            |   Simulates the final data destination bus
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 Revision History:  09/15/24 George Ore First instance of code
                    09/16/24 George Ore Formated file
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;*/

/*******************************************************************************
;*                              PROCESSES                                      *
;******************************************************************************/

/* test_child:

 Description: Generates random data to be sent up the network. This child is
        meant to be attached to every node in the network.

 Operation: The module resets all of its outputs before begining an infinite
        loop. To be robust, each child will have various parameters to simulate
        variance in data. It must satisfy a triggering chance parameter before
        starting the data transmission. At the trigger condition, it will select
        a random packet length between 1-8. It will send four bit data words
        with a binomial(.5) distribution for selecting 0 or 1 on the three data
        bits. The final termination bit will be 0 until the final word of the
        packet where it will be 1.

 Features:
    - Variable firing chance
        FOR NOW HARD STUCK AT 12.5% FIRING CHANCE
    - Random packet length
        FOR NOW WE ARE HAVING A MINIMUM PACKET LENGTH OF 1 WORD
    - Randomized packet content
        FOR NOW HAS UNBIASES 50/50 CHANCE

 Input Ports:   Name    |   Purpose
                p_a     |   Parent acknowledge
                R       |   Random 3 bit integer
                reset   |   Reset signal

 Output Ports:  Name    |   Purpose (for all: send generated data)
                p0_0    |   Parent bit 0 low line 
                p0_1    |   Parent bit 0 high line 
                p1_0    |   Parent bit 1 low line
                p1_1    |   Parent bit 1 high line
                p2_0    |   Parent bit 2 low line
                p2_1    |   Parent bit 2 high line
                pt_0    |   Parent temination bit low line
                pt_1    |   Parent termination bit high line

 Local variables:    Name    |   Purpose
                    randc   |   Random activation chance var 
                    randl   |   Random packet length var
                    rand0   |   Random bit 0 data var
                    rand1   |   Random bit 1 data var
                    rand2   |   Random bit 2 data var

 Error Handling:    None.
 Known Bugs:        None.
 Limitations:       None.

 Revision History:  09/15/24    George Ore  First instance of code
                    09/16/24    George Ore  wip

 Pseudo Code:
  
  while(1)
    result = roll_dice()
    if result == win
      plength = roll_dice()
      for (i=0; i<plength-1; i++)
        send_packet(b0=roll_dice(), b1=roll_dice(), b2=roll_dice(), tcond=0)
      send_packet(b0=roll_dice(), b1=roll_dice(), b2=roll_dice(), tcond=1)
*/
defproc test_child(bool! p0_0; bool! p0_1;   //Output channels
                    bool! p1_0; bool! p1_1;
                    bool! p2_0; bool! p2_1;
                    bool! pt_0; bool! pt_1;
                    bool? p_a;              //Input channels
                    chan?(int<3>) R;        //Random source
                    bool? reset){           //Reset signal
    int randc;  //Firing chance
    int randl;  //Packet length
    int rand0;  //For random bit content
    int rand1;
    int rand2;
    
  chp {
        //Reset all signals if reset condition is on
        [reset -> p0_0-, p0_1-, p1_0-, p1_1-, p2_0-, p2_1-, pt_0-, pt_1-];

        *[ /* fire if random chance condition is met */
            R?randc;     //Roll for activation
            [(randc = 3) ->
                //OMG YOU GOT LUCKY IT ACTIVATED
                R?randl;     //Roll for packet length
                *[randl >= 0 -> //Send a random set of bits for each word 

                     /* send random data in parallel */
                    // SEE WHAT THE SYNTAX IS FOR WRAPPING 

                        (R?rand0;//Roll for bit value 0
                        [  (rand0 > 3) -> p0_0+; [pa]; p0_0-; [~pa]
                        [] (rand0 < 4) -> p0_1+; [pa]; p0_1-; [~pa]
                        ])
                    ,
                        (R?rand1;//Roll for bit value 1
                        [  (rand1 > 3) -> p1_0+; [pa]; p1_0-; [~pa]
                        [] (rand1 < 4) -> p1_1+; [pa]; p1_1-; [~pa]
                        ])
                    ,
                        (R?rand2;//Roll for bit value 2
                        [  (rand2 > 3) -> p2_0+; [pa]; p2_0-; [~pa]
                        [] (rand2 < 4) -> p2_1+; [pa]; p2_1-; [~pa]
                        ])
                    ,
                        //Bit value t must be 0 until the last word
                        ([  (randl != 0) -> pt_0+; [pa]; pt_0-; [~pa]
                        [] (randl  = 0) -> pt_1+; [pa]; pt_1-; [~pa]
                        ]);
                    

                    randl := randl - 1
                ]
            [] (randc != 3) -> 
                //If not then you are unlucky :(
                skip
            ]
            //ADD A WAIT OR DELAY???????
        ]
    }
}

/* test_root:

 Description: Emulates the final output bus for packets to be sent & processed.
        This is a root is designed to take in any combination of data 
        permutations from the input bus. In testing, these ports can be watched.

 Operation: The root begins by setting its output low. Then it waits for one
        of the deterministically defined input permutations. Once all are 
        received, it sends an acknowledge and waits until all data is off
        to deactivate the acknowledge.

 Features:
    - 4 bit (8 line) input processing
    - Can receive any permutation of data input
    - Sends acks to the sender

 Input Ports:   Name    |   Purpose
                c[8]    |   8 bit bus containing child data   

 Output Ports:  Name    |   Purpose
                c_a     |   Child acknowledge

 Error Handling:    None.
 Known Bugs:        None.
 Limitations:       None.

 Revision History:  09/15/24    George Ore  First instance of code
                    09/16/24    George Ore  wip

 Pseudo Code
   all_out_off();
   while(1)
       wait_for_child_data_on()
       ack_on()
       wait_for_child_data_off()
       ack_off()
*/
defproc test_root(bool? c[8]; bool! c_a){
    
    hse { 
            c_a-;  //Start with the acknowledge off
            
            *[ /*Start off by waiting for one of the conditions to come true*/
                
                //I USED LITTLE ENDIAN SHOOT ME
                [  c[0] & c[2] & c[4] & c[6]    //0000
                [] c[1] & c[2] & c[4] & c[6]    //1000
                [] c[0] & c[3] & c[4] & c[6]    //0100
                [] c[1] & c[3] & c[4] & c[6]    //1100
                [] c[0] & c[2] & c[5] & c[6]    //0010
                [] c[1] & c[2] & c[5] & c[6]    //1010
                [] c[0] & c[3] & c[5] & c[6]    //0110
                [] c[1] & c[3] & c[5] & c[6]    //1110
                [] c[0] & c[2] & c[4] & c[7]    //0001
                [] c[1] & c[2] & c[4] & c[7]    //1001
                [] c[0] & c[3] & c[4] & c[7]    //0101
                [] c[1] & c[3] & c[4] & c[7]    //1101
                [] c[0] & c[2] & c[5] & c[7]    //0011
                [] c[1] & c[2] & c[5] & c[7]    //1011
                [] c[0] & c[3] & c[5] & c[7]    //0111
                [] c[1] & c[3] & c[5] & c[7]    //1111
                ];
            //THIS CAN BE XORED ^^^^

            // for reference [c[0] | c[1] | c[2] | c[3] | c[4] | c[5] | c[6] | c[7]];

            //Acknowledge that foo
            c_a+;

            //Now wait until all of them are off
            [~c[0] & ~c[1] & ~c[2] & ~c[3] & ~c[4] & ~c[5] & ~c[6] & ~c[7]];

            //Acknowledge that foo
            c_a-
            ]
        }
}

defproc test(){
    // Create random source 
    pint D_WIDTH = 3;
    sim::rand::source_simple<D_WIDTH, 1, false> src;
    // Setup reset signal
    bool reset;

    // Define a root node and a test child
	test_child tc;
	test_root tr;
    
    // Connect wires
    tc.R = src.0;
    tc.reset = reset;
    tc.p_a = tr.c_a;

    tr.c[0] = tc.p0_0;
    tr.c[1] = tc.p0_1;
    tr.c[2] = tc.p1_0;
    tr.c[3] = tc.p1_1;
    tr.c[4] = tc.p2_0;
    tr.c[5] = tc.p2_1;
    tr.c[6] = tc.pt_0;
    tr.c[7] = tc.pt_1;

}

/*******************************************************************************
;*                              Testing Script                                 *
;*******************************************************************************

//Reset mode run
set reset 1     - Sets reset signal on
mode reset      - Turn on simulator's reset mode
cycle           - Run until end of program

//Normal mode run
mode run        - Turn on simulator's normal mode
cycle           - Run until end of program

//Stress testing
set reset 0     - Turn off the reset control signal
random          - Turn on random timing intervals
break-on-warn   - Set break on warnings
status X        - Print all signals with X state (undriven or driven both ways)
status 1        - Print all signals with 1 state
status 0        - Print all signals with 0 state

//Set watches on all relevant signals
watch "tr.c[0]" "tr.c[1]" "tr.c[2]" "tr.c[3]" "tr.c[4]" "tr.c[5]" "tr.c[6]" "tr.c[7]" "tc.p_a"

//Run simulation for a large time interal
advance 1000000000  - Run sim for a long time
status X            - Print all signals with X state

*/

